This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-03T12:36:12.675Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
migrations/
  deploy.ts
programs/
  limit-order-simulator/
    src/
      lib.rs
    Cargo.toml
    Xargo.toml
tests/
  limit-order-simulator.ts
.gitignore
.prettierignore
Anchor.toml
Cargo.toml
package.json
tsconfig.json

================================================================
Files
================================================================

================
File: migrations/deploy.ts
================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

import * as anchor from "@coral-xyz/anchor";

module.exports = async function (provider: anchor.AnchorProvider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};

================
File: programs/limit-order-simulator/src/lib.rs
================
use anchor_lang::prelude::*;

declare_id!("3P6a1VTBgj7bdZQavHe4Hpv2SfJxxgzU8ju9Vtct52Pg");

#[program]
pub mod limit_order_simulator {
    use super::*;

    pub fn create_order(
        ctx: Context<CreateOrder>,
        token: String,
        amount: u64,
        limit_price: u64,
        order_id: u64,
    ) -> Result<()> {
        let order = &mut ctx.accounts.order;
        order.owner = *ctx.accounts.user.key;
        order.token = token;
        order.amount = amount;
        order.limit_price = limit_price;
        order.is_executed = false;
        order.order_id = order_id;
        Ok(())
    }

    pub fn execute_order(
        ctx: Context<ExecuteOrder>,
        current_price: u64,
        order_id: u64,
    ) -> Result<()> {
        let order = &mut ctx.accounts.order;
        if order.is_executed {
            return err!(ErrorCode::AlreadyExecuted);
        }
        if current_price != order.limit_price {
            return err!(ErrorCode::PriceMismatch);
        }
        order.is_executed = true;
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(order_id: u64)]
pub struct CreateOrder<'info> {
    #[account(
        init,
        payer = user,
        space = 8 + 32 + 32 + 8 + 8 + 1 + 8, // discriminator + owner + token (assuming 32 bytes) + amount + limit_price + is_executed + order_id
        seeds = [b"order", user.key().as_ref(), order_id.to_le_bytes().as_ref()],
        bump
    )]
    pub order: Account<'info, Order>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
#[instruction(order_id: u64)]
pub struct ExecuteOrder<'info> {
    #[account(
        mut,
        seeds = [b"order", user.key().as_ref(), order_id.to_le_bytes().as_ref()],
        bump
    )]
    pub order: Account<'info, Order>,
    pub user: Signer<'info>,
}

#[account]
pub struct Order {
    pub owner: Pubkey,
    pub token: String,
    pub amount: u64,
    pub limit_price: u64,
    pub is_executed: bool,
    pub order_id: u64,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Order has already been executed")]
    AlreadyExecuted,
    #[msg("Current price does not match limit price")]
    PriceMismatch,
}

================
File: programs/limit-order-simulator/Cargo.toml
================
[package]
name = "limit-order-simulator"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "limit_order_simulator"

[features]
default = []
cpi = ["no-entrypoint"]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
idl-build = ["anchor-lang/idl-build"]


[dependencies]
anchor-lang = "0.31.0"

================
File: programs/limit-order-simulator/Xargo.toml
================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================
File: tests/limit-order-simulator.ts
================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { LimitOrderSimulator } from "../target/types/limit_order_simulator";
import { PublicKey } from "@solana/web3.js";

describe("limit-order-simulator", () => {
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.LimitOrderSimulator as Program<LimitOrderSimulator>;
  const provider = anchor.AnchorProvider.env();

  it("Creates a limit order", async () => {
    const orderId = 1;
    const [orderPda, bump] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("order"),
        provider.wallet.publicKey.toBuffer(),
        new anchor.BN(orderId).toArrayLike(Buffer, "le", 8),
      ],
      program.programId
    );
    console.log("PDA for orderId 1:", orderPda.toBase58());
    const tx = await program.methods
      .createOrder("SOL", new anchor.BN(1_000_000), new anchor.BN(100), new anchor.BN(orderId))
      .accounts({
        order: orderPda,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc();
    console.log("Create order transaction:", tx);
  });

  it("Executes a limit order", async () => {
    const orderId = 2; // Unique orderId
    const [orderPda, bump] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("order"),
        provider.wallet.publicKey.toBuffer(),
        new anchor.BN(orderId).toArrayLike(Buffer, "le", 8),
      ],
      program.programId
    );
    console.log("PDA for orderId 2:", orderPda.toBase58());

    // Create the order first
    await program.methods
      .createOrder("SOL", new anchor.BN(1_000_000), new anchor.BN(100), new anchor.BN(orderId))
      .accounts({
        order: orderPda,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc();

    // Then execute it
    const tx = await program.methods
      .executeOrder(new anchor.BN(100), new anchor.BN(orderId))
      .accounts({
        order: orderPda,
        user: provider.wallet.publicKey,
      })
      .rpc();
    console.log("Execute order transaction:", tx);
  });
});

================
File: .gitignore
================
.anchor
.DS_Store
target
**/*.rs.bk
node_modules
test-ledger
.yarn

================
File: .prettierignore
================
.anchor
.DS_Store
target
node_modules
dist
build
test-ledger

================
File: Anchor.toml
================
[toolchain]
package_manager = "yarn"

[features]
resolution = true
skip-lint = false

[programs.localnet]
limit_order_simulator = "3P6a1VTBgj7bdZQavHe4Hpv2SfJxxgzU8ju9Vtct52Pg"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"

================
File: Cargo.toml
================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1

================
File: package.json
================
{
  "license": "ISC",
  "scripts": {
    "lint:fix": "prettier */*.js \"*/**/*{.js,.ts}\" -w",
    "lint": "prettier */*.js \"*/**/*{.js,.ts}\" --check"
  },
  "dependencies": {
    "@coral-xyz/anchor": "^0.31.0",
    "yarn": "^1.22.22"
  },
  "devDependencies": {
    "@types/bn.js": "^5.1.0",
    "@types/chai": "^4.3.0",
    "@types/mocha": "^9.0.0",
    "chai": "^4.3.4",
    "mocha": "^9.0.3",
    "prettier": "^2.6.2",
    "ts-mocha": "^10.0.0",
    "typescript": "^5.7.3"
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}
